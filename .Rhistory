library(rpart)
library(adabag)
library(ada)
rand.fit = randomForest(review_scores_rating~., data = trainR, ntree = 500, na.action=na.exclude)
varImpPlot(rand.fit, sort = T, main = "Training Model Top 15 Variable Importance", n.var = 15)
rand.predictions = predict(rand.fit, newdata = testR)
nas = which(is.na(rand.predictions) == TRUE)
misClasificError <- mean(rand.predictions != testR$review_scores_rating)
print(paste('Accuracy',1-misClasificError))
# review.pre = review.pre[, -c(9,19)]
# review.post = review.post[, -c(9,19)]
# common <- intersect(names(review.pre), names(review.post))
# for (p in common) {
#   if (class(review.pre[[p]]) == "factor") {
#     levels(review.post[[p]]) <- levels(review.pre[[p]])
#   }
# }
#
# rand.fit.test = randomForest(review_scores_rating~., data = review.pre, ntree = 500, mtry = 4)
# #res = tuneRF(x = subset(review.pre, select = -review_scores_rating), y = review.pre$review_scores_rating, ntreeTry=500, doBest = T)
# rf.c = predict(rand.fit.test, newdata = review.post)
#
# rand.predictions.test.fit = predict(rand.fit.test, newdata = review.post)
#
# nfold = 5
# samp <- sample(rep(1:nfold, ceiling(nrow(review.pre)/nfold))[1:nrow(review.pre)])
# misclass = c()
# for(k in 1:nfold) {
#   testd <- review.pre[which(samp==k), ]
#   traind <- review.pre[-which(samp==k), ]
#   rf = randomForest(review_scores_rating~., data = traind, ntree = 500, mtry = 4)
#   rf.pred = predict(rf, newdata = testd)
#   misclass[k] = mean(rf.pred != testd$review_scores_rating)
# }
# misclass = mean(misclass)
# misclass
wrong = wrong(rand.predictions != testR$review_scores_rating)
wrong = which(rand.predictions != testR$review_scores_rating)
length(wrong)
wrongD = testR[wrong,]
View(wrongD)
colnames(tesR)
colnames(testR)
length(which(wrongD$bed_type == "Real Bed")) / length(wrong)
table(wrongD)
summary(wrongD)
head(price$host_response_time,1)
wrongD = review[wrong,]
View(wrongD)
models = c("Linear","Lasso", "Ridge", "Tree", "Pruned Tree", "Random Forest")
mse = c(9188,8940,8942,6572,6999,4005)
kable(cbind(models,mse))
library(knitr)
models = c("Linear","Lasso", "Ridge", "Tree", "Pruned Tree", "Random Forest")
mse = c(9188,8940,8942,6572,6999,4005)
kable(cbind(models,mse))
knitr::opts_chunk$set(echo = TRUE) # show code
knitr::opts_chunk$set(warning = TRUE) # hide warnings
knitr::opts_chunk$set(message = FALSE) # hide messages
knitr::opts_chunk$set(cache = TRUE) # cache results
options(np.messages = FALSE)
library(stringr)
library(geosphere)
library(e1071)
price = read.csv("price.csv")
review = read.csv("review.csv")
price.t = read.csv("price_test.csv")
review.t = read.csv("review_test.csv")
review.pre = review
review.pre$host_is_superhost = as.factor(as.numeric(review.pre$host_is_superhost) -1)
review.pre$host_identity_verified = as.factor(as.numeric(review.pre$host_identity_verified) -1)
review.pre$instant_bookable = as.factor(as.numeric(review.pre$instant_bookable) -1)
review.pre$host_response_rate = as.numeric(sub("%", "", review.pre$host_response_rate)) / 100
review.pre$host_response_time = as.factor(unclass(review.pre$host_response_time) -1)
review.pre$cleaning_fee = as.numeric(sub("$", "", review.pre$cleaning_fee, fixed = T))
review.pre$price = as.numeric(gsub("$", "", review.pre$price, fixed = T))
review.pre$cancellation_policy = as.factor(as.numeric(review.pre$cancellation_policy))
review.pre$review_scores_rating = as.factor(as.numeric(review.pre$review_scores_rating))
review.pre$cleaning_fee[is.na(review.pre$cleaning_fee)] = 0
review.pre$price[is.na(review.pre$price)] = 0
review.post = review.t
review.post$host_is_superhost = as.factor(as.numeric(review.post$host_is_superhost) -1)
review.post$host_identity_verified = as.factor(as.numeric(review.post$host_identity_verified) -1)
review.post$instant_bookable = as.factor(as.numeric(review.post$instant_bookable) -1)
review.post$host_response_rate = as.numeric(sub("%", "", review.post$host_response_rate)) / 100
review.post$host_response_time = as.factor(unclass(review.post$host_response_time) -1)
review.post$cleaning_fee = as.numeric(sub("$", "", review.post$cleaning_fee, fixed = T))
review.post$price = as.numeric(gsub("$", "", review.post$price, fixed = T))
review.post$cancellation_policy = as.factor(as.numeric(review.post$cancellation_policy))
review.post$cleaning_fee[is.na(review.post$cleaning_fee)] = 0
review.post$price[is.na(review.post$price)] = 0
dim(review.pre) ; dim(review.post)
# library: stringr
amenities = sapply(review.pre$amenities, FUN=function(x) {
# some function that just splits up all the words in each row of amenities
s = toString(x)
s = strsplit(s[[1]],",")
newS = str_replace(s[[1]],'\\{',"")
newS = str_replace(newS,'\\}',"")
newS = str_replace(newS,'\"',"")
newS = str_replace(newS,'\"',"")
tolower(newS)
})
amenitiesPost = sapply(review.post$amenities, FUN=function(x) {
# some function that just splits up all the words in each row of amenities
s = toString(x)
s = strsplit(s[[1]],",")
newS = str_replace(s[[1]],'\\{',"")
newS = str_replace(newS,'\\}',"")
newS = str_replace(newS,'\"',"")
newS = str_replace(newS,'\"',"")
tolower(newS)
})
num.amenities = c()
for(i in 1:length(review.pre$amenities)) {
num.amenities[i] = length(amenities[[i]])
}
num.amenities.post = c()
for(i in 1:length(review.post$amenities)) {
num.amenities.post[i] = length(amenitiesPost[[i]])
}
review.post$num_amenities = num.amenities.post
review.pre$num_amenities = num.amenities
listOfAmenities = c()
for (i in c(1:length(review.pre$amenities))) {
temp = amenities[[i]]
listOfAmenities = c(listOfAmenities,temp)
}
t = sort(table(listOfAmenities),decreasing = TRUE)
# t[1:30]
# library: geosphere
pike.place.lat = 47.6097 ; pike.place.long = -122.3422
space.needle.lat = 47.6205 ; space.needle.long = -122.3493
downtown.lat = 47.6050 ; downtown.long = -122.3344
gum.wall.lat = 47.6084 ; gum.wall.long = -122.3404
great.wheel.lat = 47.6062 ; great.wheel.long = -122.3425
pike.dist = c()
space.dist = c()
downtown.dist = c()
gum.dist = c()
wheel.dist = c()
for(i in 1:length(review.pre$latitude)) {
pike.dist[i] = distm(c(pike.place.long, pike.place.lat), c(review.pre$longitude[i], review.pre$latitude[i]), fun = distGeo) / 1609.344
space.dist[i] = distm(c(space.needle.long, space.needle.lat), c(review.pre$longitude[i], review.pre$latitude[i]), fun = distGeo) / 1609.344
downtown.dist[i] = distm(c(downtown.long, downtown.lat), c(review.pre$longitude[i], review.pre$latitude[i]), fun = distGeo) / 1609.344
gum.dist[i] = distm(c(gum.wall.long, gum.wall.lat), c(review.pre$longitude[i], review.pre$latitude[i]), fun = distGeo) / 1609.344
wheel.dist[i] = distm(c(great.wheel.long, great.wheel.lat), c(review.pre$longitude[i], review.pre$latitude[i]), fun = distGeo) / 1609.344
}
review.pre$pike_dist = pike.dist ; review.pre$space_dist = space.dist
review.pre$downtown_dist = downtown.dist ; review.pre$gum_dist = gum.dist
review.pre$wheel_dist = wheel.dist
###
pike.dist.post = c()
space.dist.post = c()
downtown.dist.post = c()
gum.dist.post = c()
wheel.dist.post = c()
for(i in 1:length(review.post$latitude)) {
pike.dist.post[i] = distm(c(pike.place.long, pike.place.lat), c(review.post$longitude[i], review.post$latitude[i]),
fun = distGeo) / 1609.344
space.dist.post[i] = distm(c(space.needle.long, space.needle.lat), c(review.post$longitude[i], review.post$latitude[i]),
fun = distGeo) / 1609.344
downtown.dist.post[i] = distm(c(downtown.long, downtown.lat), c(review.post$longitude[i], review.post$latitude[i]),
fun = distGeo) / 1609.344
gum.dist.post[i] = distm(c(gum.wall.long, gum.wall.lat), c(review.post$longitude[i], review.post$latitude[i]),
fun = distGeo) / 1609.344
wheel.dist.post[i] = distm(c(great.wheel.long, great.wheel.lat), c(review.post$longitude[i], review.post$latitude[i]),
fun = distGeo) / 1609.344
}
review.post$pike_dist = pike.dist.post ; review.post$space_dist = space.dist.post
review.post$downtown_dist = downtown.dist.post ; review.post$gum_dist = gum.dist.post
review.post$wheel_dist = wheel.dist.post
dim(review.pre) ; dim(review.post)
nR <- nrow(review.pre)
review.price <- review.pre[sample(nR), ]
train.indicesR <- 1:round(0.7 * nR)
trainR <- review.price[train.indicesR,]
test.indicesR <- (round(0.7 * nR) + 1):nR
testR <- review.price[test.indicesR,]
trainR <- trainR[-c(9,17,19)]
testR <- testR[-c(9,17,19)]
review.pre <- review.pre[-c(9,18,19)]
review.post <- review.post[-c(9,18,19)]
# data[!(data$property_type %in% whatever), ]
NB = naiveBayes(review_scores_rating ~ ., data = trainR)
predictions.nb = predict(NB, newdata = testR)
mse.nb = mean((testR$review_scores_rating != predictions.nb)^2)
mse.nb
logRegMdl = glm(review_scores_rating ~., data = trainR, family = "binomial")
logReg.results <- predict(logRegMdl,newdata=testR,type='response')
logReg.results <- ifelse(logReg.results > 0.5,1,0)
nas = which(is.na(logReg.results))
misClasificError <- mean(logReg.results != testR$review_scores_rating)
print(paste('Accuracy',1-misClasificError))
plot(logRegMdl)
library(randomForest)
library(gbm)
library(rpart)
library(adabag)
library(ada)
rand.fit = randomForest(review_scores_rating~., data = trainR, ntree = 500, na.action=na.exclude)
# varImpPlot(rand.fit, sort = T, main = "Training Model Top 15 Variable Importance", n.var = 15)
rand.predictions = predict(rand.fit, newdata = testR)
nas = which(is.na(rand.predictions) == TRUE)
misClasificError <- mean(rand.predictions != testR$review_scores_rating)
print(paste('Accuracy',1-misClasificError))
# wrong = which(rand.predictions != testR$review_scores_rating)
#
# wrongD = review[wrong,]
review.pre = review.pre[, -c(9,19)]
review.post = review.post[, -c(9,19)]
common <- intersect(names(review.pre), names(review.post))
for (p in common) {
if (class(review.pre[[p]]) == "factor") {
levels(review.post[[p]]) <- levels(review.pre[[p]])
}
}
rand.fit.test = randomForest(review_scores_rating~., data = review.pre, ntree = 500, mtry = 4)
#res = tuneRF(x = subset(review.pre, select = -review_scores_rating), y = review.pre$review_scores_rating, ntreeTry=500, doBest = T)
rf.c = predict(rand.fit.test, newdata = review.post)
rand.predictions.test.fit = predict(rand.fit.test, newdata = review.post)
nfold = 5
samp <- sample(rep(1:nfold, ceiling(nrow(review.pre)/nfold))[1:nrow(review.pre)])
misclass = c()
for(k in 1:nfold) {
testd <- review.pre[which(samp==k), ]
traind <- review.pre[-which(samp==k), ]
rf = randomForest(review_scores_rating~., data = traind, ntree = 500, mtry = 4)
rf.pred = predict(rf, newdata = testd)
misclass[k] = mean(rf.pred != testd$review_scores_rating)
}
misclass = mean(misclass)
misclass
# samp.price = sample(rep(1:nfold, ceiling(nrow(price.pre)/nfold))[1:nrow(price.pre)])
# mse = c()
# for(k in 1:nfold) {
#   testd <- price.pre[which(samp.price==k), ]
#   traind <- price.pre[-which(samp.price==k), ]
#   rf.reg = randomForest(price~., data = traind, ntree = 500)
#   rf.reg.pred = predict(rf.reg, newdata = testd)
#   mse[k] = mean((rf.reg.pred - testd$price)^2)
# }
# mse = mean(mse)
# misclass = mean(rand.predictions.test.fit != review.pre$review_scores_rating)
boost = boosting(review_scores_rating~., data = review.pre, mfinal = 100, coeflearn = "Freund")
# tune.svm(review_scores_rating~.,data=trainR)
svmfitLinear <-svm(review_scores_rating~., data=trainR,kernel='linear')
misClasificError <- mean(predict(svmfitLinear, newdata=testR)!=testR$review_scores_rating)
print(paste('Accuracy',misClasificError))
svmfitPoly <-svm(review_scores_rating~., data=trainR,kernel='polynomial')
misClasificError <- mean(predict(svmfitPoly, newdata=testR)!=testR$review_scores_rating)
print(paste('Accuracy',misClasificError))
svmfitRadial <-svm(review_scores_rating~., data=trainR,kernel='radial')
misClasificError <- mean(predict(svmfitRadial, newdata=testR)!=testR$review_scores_rating)
print(paste('Accuracy',misClasificError))
# tune.out.linear = tune(svm, review_scores_rating~., data = trainR, kernel ='linear', ranges =list(cost =c(.1, 1, 10, 100, 1000, 1e4, 1e5, 1e6),
#                                                                        gamma =c(0.01, 0.05, .1, .5, 1, 2, 3)))
# tune.out.linear$best.model
# tune.out.poly = tune(svm, review_scores_rating~., data = trainR, kernel ='polynomial', ranges =list(cost =c(.1, 1, 10, 100, 1000, 1e4, 1e5, 1e6),
#                                                                        gamma =c(0.01, 0.05, .1, .5, 1, 2, 3)))
# tune.out.poly$best.model
# tune.out.radial = tune(svm, review_scores_rating~., data = trainR, kernel ='radial', ranges =list(cost =c(.1, 1, 10, 100, 1000, 1e4, 1e5, 1e6),
#                                                                        gamma =c(0.01, 0.05, .1, .5, 1, 2, 3)))
# tune.out.radial$best.model
knitr::opts_chunk$set(echo = TRUE)
boston = read.csv("listings-3.csv")
boston = read.csv("listings-3.csv.gz")
boston = read.csv("listings-3.csv")
boston = read.csv("listings-3.csv")
boston = read.csv("listings.csv")
colnames(review)
boston.reduced = subset(boston, select = c("id","host_response_time", "host_response_rate", "host_is_superhost", "host_identity_verified", "host_listings_count", "neighbourhood_group_cleansed", "property_type", "room_type", "latitude", "longitude", "guests_included", "accommodates",  "bathrooms", "bedrooms", "beds",  "amenities",  "price" , "cleaning_fee", "minimum_nights", "maximum_nights", "instant_bookable", "cancellation_policy", "review_scores_rating"))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$review_scores_rating[is.na(boston.reduced$review_scores_rating)] = 0
boston.reduced$host_is_superhost = as.factor(as.numeric(boston.reduced$host_is_superhost) -1)
boston.reduced$host_identity_verified = as.factor(as.numeric(boston.reduced$host_identity_verified) -1)
boston.reduced$instant_bookable = as.factor(as.numeric(boston.reduced$instant_bookable) -1)
boston.reduced$host_response_rate = as.numeric(sub("%", "", boston.reduced$host_response_rate)) / 100
boston.reduced$host_response_time = as.factor(unclass(boston.reduced$host_response_time) -1)
boston.reduced$cleaning_fee = as.numeric(sub("$", "", boston.reduced$cleaning_fee, fixed = T))
boston.reduced$price = as.numeric(gsub("$", "", boston.reduced$price, fixed = T))
boston.reduced$cancellation_policy = as.factor(as.numeric(boston.reduced$cancellation_policy))
boston.reduced$review_scores_rating = as.factor(as.numeric(boston.reduced$review_scores_rating))
boston.reduced$cleaning_fee[is.na(boston.reduced$cleaning_fee)] = 0
boston.reduced$price[is.na(boston.reduced$price)] = 0
boston.reduced$host_listings_count[is.na(boston.reduced$host_listings_count)] = 0
boston.reduced$bathrooms[is.na(boston.reduced$bathrooms)] = 0
boston.reduced$bedrooms[is.na(boston.reduced$bedrooms)] = 0
boston.reduced$beds[is.na(boston.reduced$beds)] = 0
boston.reduced$neighbourhood_group_cleansed = NULL
boston.reduced$host_response_rate = NULL
sum(is.na(boston.reduced))
View(boston.reduced)
# sum(is.na(boston.reduced))
summary(boston.reduced)
head(boston.reduced$review_scores_rating,1)
head(boston.reduced$review_scores_rating,2)
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
greater = which(boston.reduced$review_scores_rating > 95 || boston.reduced$review_scores_rating == 95) # as 1
greater = which(boston.reduced$review_scores_rating < 90 || boston.reduced$review_scores_rating == 90) # as 0
greater = which(boston.reduced$review_scores_rating > 95 || boston.reduced$review_scores_rating == 95) # as 1
less = which(boston.reduced$review_scores_rating < 90 || boston.reduced$review_scores_rating == 90) # as 0
greater = which(as.numeric(boston.reduced$review_scores_rating) > 95 || as.numeric(boston.reduced$review_scores_rating) == 95) # as 1
less = which(as.numeric(boston.reduced$review_scores_rating) < 90 || as.numeric(boston.reduced$review_scores_rating) == 90) # as 0
greater
as.numeric(boston.reduced$review_scores_rating)
as.numeric(boston.reduced$review_scores_rating) > 95
as.numeric(boston.reduced$review_scores_rating) < 90
which(as.numeric(boston.reduced$review_scores_rating) > 95)
which(as.numeric(boston.reduced$review_scores_rating) < 90)
knitr::opts_chunk$set(echo = TRUE)
boston = read.csv("listings.csv")
boston.reduced = subset(boston, select = c("id","host_response_time", "host_response_rate", "host_is_superhost", "host_identity_verified", "host_listings_count", "neighbourhood_group_cleansed", "property_type", "room_type", "latitude", "longitude", "guests_included", "accommodates",  "bathrooms", "bedrooms", "beds",  "amenities",  "price" , "cleaning_fee", "minimum_nights", "maximum_nights", "instant_bookable", "cancellation_policy", "review_scores_rating"))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$review_scores_rating[is.na(boston.reduced$review_scores_rating)] = 0
boston.reduced$host_is_superhost = as.factor(as.numeric(boston.reduced$host_is_superhost) -1)
boston.reduced$host_identity_verified = as.factor(as.numeric(boston.reduced$host_identity_verified) -1)
boston.reduced$instant_bookable = as.factor(as.numeric(boston.reduced$instant_bookable) -1)
boston.reduced$host_response_rate = as.numeric(sub("%", "", boston.reduced$host_response_rate)) / 100
boston.reduced$host_response_time = as.factor(unclass(boston.reduced$host_response_time) -1)
boston.reduced$cleaning_fee = as.numeric(sub("$", "", boston.reduced$cleaning_fee, fixed = T))
boston.reduced$price = as.numeric(gsub("$", "", boston.reduced$price, fixed = T))
boston.reduced$cancellation_policy = as.factor(as.numeric(boston.reduced$cancellation_policy))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$cleaning_fee[is.na(boston.reduced$cleaning_fee)] = 0
boston.reduced$price[is.na(boston.reduced$price)] = 0
boston.reduced$host_listings_count[is.na(boston.reduced$host_listings_count)] = 0
boston.reduced$bathrooms[is.na(boston.reduced$bathrooms)] = 0
boston.reduced$bedrooms[is.na(boston.reduced$bedrooms)] = 0
boston.reduced$beds[is.na(boston.reduced$beds)] = 0
boston.reduced$neighbourhood_group_cleansed = NULL
boston.reduced$host_response_rate = NULL
# sum(is.na(boston.reduced))
greater = which(boston.reduced$review_scores_rating > 95 || boston.reduced$review_scores_rating == 95) # as 1
less = which(boston.reduced$review_scores_rating < 90 || boston.reduced$review_scores_rating == 90) # as 0
length(greater)
length(less)
which(boston.reduced$review_scores_rating > 95)
which(boston.reduced$review_scores_rating < 90)
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
less = which(boston.reduced$review_scores_rating < 90) # as 0
head(greater)
indices = c(greater,less)
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
less = which(boston.reduced$review_scores_rating < 90) # as 0
head(greater)
indices = c(greater,less)
boston.reduced = boston.reduced[indices,]
knitr::opts_chunk$set(echo = TRUE)
boston = read.csv("listings.csv")
boston.reduced = subset(boston, select = c("id","host_response_time", "host_response_rate", "host_is_superhost", "host_identity_verified", "host_listings_count", "neighbourhood_group_cleansed", "property_type", "room_type", "latitude", "longitude", "guests_included", "accommodates",  "bathrooms", "bedrooms", "beds",  "amenities",  "price" , "cleaning_fee", "minimum_nights", "maximum_nights", "instant_bookable", "cancellation_policy", "review_scores_rating"))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$review_scores_rating[is.na(boston.reduced$review_scores_rating)] = 0
boston.reduced$host_is_superhost = as.factor(as.numeric(boston.reduced$host_is_superhost) -1)
boston.reduced$host_identity_verified = as.factor(as.numeric(boston.reduced$host_identity_verified) -1)
boston.reduced$instant_bookable = as.factor(as.numeric(boston.reduced$instant_bookable) -1)
boston.reduced$host_response_rate = as.numeric(sub("%", "", boston.reduced$host_response_rate)) / 100
boston.reduced$host_response_time = as.factor(unclass(boston.reduced$host_response_time) -1)
boston.reduced$cleaning_fee = as.numeric(sub("$", "", boston.reduced$cleaning_fee, fixed = T))
boston.reduced$price = as.numeric(gsub("$", "", boston.reduced$price, fixed = T))
boston.reduced$cancellation_policy = as.factor(as.numeric(boston.reduced$cancellation_policy))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$cleaning_fee[is.na(boston.reduced$cleaning_fee)] = 0
boston.reduced$price[is.na(boston.reduced$price)] = 0
boston.reduced$host_listings_count[is.na(boston.reduced$host_listings_count)] = 0
boston.reduced$bathrooms[is.na(boston.reduced$bathrooms)] = 0
boston.reduced$bedrooms[is.na(boston.reduced$bedrooms)] = 0
boston.reduced$beds[is.na(boston.reduced$beds)] = 0
boston.reduced$neighbourhood_group_cleansed = NULL
boston.reduced$host_response_rate = NULL
# sum(is.na(boston.reduced))
dim(boston.reduced)
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
less = which(boston.reduced$review_scores_rating < 90) # as 0
indices = c(greater,less)
boston.reduced = boston.reduced[indices,]
dim(boston.reduced)
table(boston.reduced$review_scores_rating)
dim(boston.reduced)
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
less = which(boston.reduced$review_scores_rating <= 90) # as 0
indices = c(greater,less)
boston.reduced = boston.reduced[indices,]
dim(boston.reduced)
boston.reduced$review_scores_rating = ifelse(boston.reduced$review_scores_rating <= 90,0,1)
head(boston.reduced$review_scores_rating)
boston.reduced$host_is_superhost
table(boston.reduced$host_is_superhost)
which(boston.reduced$host_is_superhost == 0)
table(boston.reduced$host_response_time)
which(boston.reduced$host_response_time == 0)
which(boston.reduced$host_response_time == 0)
knitr::opts_chunk$set(echo = TRUE)
boston = read.csv("/Users/dipakkrishnan/Downloads/listings-3.csv")
boston = read.csv("listings.csv")
knitr::opts_chunk$set(echo = TRUE)
boston = read.csv("listings.csv")
boston.reduced = subset(boston, select = c("id","host_response_time", "host_response_rate", "host_is_superhost", "host_identity_verified", "host_listings_count", "neighbourhood_group_cleansed", "property_type", "room_type", "latitude", "longitude", "guests_included", "accommodates",  "bathrooms", "bedrooms", "beds",  "amenities",  "price" , "cleaning_fee", "minimum_nights", "maximum_nights", "instant_bookable", "cancellation_policy", "review_scores_rating"))
boston.reduced$host_is_superhost = as.factor(as.numeric(boston.reduced$host_is_superhost) -1)
boston.reduced$host_identity_verified = as.factor(as.numeric(boston.reduced$host_identity_verified) -1)
boston.reduced$instant_bookable = as.factor(as.numeric(boston.reduced$instant_bookable) -1)
boston.reduced$host_response_rate = as.numeric(sub("%", "", boston.reduced$host_response_rate)) / 100
boston.reduced$host_response_time = as.factor(unclass(boston.reduced$host_response_time) -1)
boston.reduced$cleaning_fee = as.numeric(sub("$", "", boston.reduced$cleaning_fee, fixed = T))
boston.reduced$price = as.numeric(gsub("$", "", boston.reduced$price, fixed = T))
boston.reduced$cancellation_policy = as.factor(as.numeric(boston.reduced$cancellation_policy))
boston.reduced$review_scores_rating = as.numeric(boston.reduced$review_scores_rating)
boston.reduced$cleaning_fee[is.na(boston.reduced$cleaning_fee)] = 0
boston.reduced$price[is.na(boston.reduced$price)] = 0
boston.reduced$host_listings_count[is.na(boston.reduced$host_listings_count)] = 0
boston.reduced$bathrooms[is.na(boston.reduced$bathrooms)] = 0
boston.reduced$bedrooms[is.na(boston.reduced$bedrooms)] = 0
boston.reduced$beds[is.na(boston.reduced$beds)] = 0
boston.reduced$neighbourhood_group_cleansed = NULL
boston.reduced$host_response_rate = NULL
greater = which(boston.reduced$review_scores_rating >= 95) # as 1
less = which(boston.reduced$review_scores_rating <= 90) # as 0
indices = c(greater,less)
boston.reduced = boston.reduced[indices,]
boston.reduced$review_scores_rating = ifelse(boston.reduced$review_scores_rating <= 90,0,1)
sum(is.na(boston.reduced))
head(boston.reduced)
# library: stringr
library(stringr)
amenities = sapply(boston.reduced$amenities, FUN=function(x) {
# some function that just splits up all the words in each row of amenities
s = toString(x)
s = strsplit(s[[1]],",")
newS = str_replace(s[[1]],'\\{',"")
newS = str_replace(newS,'\\}',"")
newS = str_replace(newS,'\"',"")
newS = str_replace(newS,'\"',"")
tolower(newS)
})
num.amenities = c()
for(i in 1:length(boston.reduced$amenities)) {
num.amenities[i] = length(amenities[[i]])
}
boston.reduced$amenities = NULL
boston.reduced$property_type = NULL
boston.reduced$num_amenities = num.amenities
library(geosphere)
fenway.lat = 42.3467 ; fenway.long = -71.0972
fanueil.lat = 42.3603 ; fanueil.long = -71.0547
freedom.lat = 42.3560 ; freedom.long = -71.0545
fenway.dist = c()
fanueil.dist = c()
freedom.dist = c()
for(i in 1:length(boston.reduced$latitude)) {
fenway.dist[i] = distm(c(fenway.long, fenway.lat), c(boston.reduced$longitude[i], boston.reduced$latitude[i]), fun = distGeo) / 1609.344
fanueil.dist[i] = distm(c(fanueil.long, fanueil.lat), c(boston.reduced$longitude[i], boston.reduced$latitude[i]), fun = distGeo) / 1609.344
freedom.dist[i] = distm(c(freedom.long, freedom.lat), c(boston.reduced$longitude[i], boston.reduced$latitude[i]), fun = distGeo) / 1609.344
}
boston.reduced$fenway_dist = fenway.dist ; boston.reduced$fanueil_dist = fanueil.dist ; boston.reduced$freedom_dist = freedom.dist
boston.reduced = boston.reduced[-1785,]
nR <- nrow(boston.reduced)
boston.review <- boston.reduced[sample(nR), ]
train.indicesR <- 1:round(0.7 * nR)
trainR <- boston.reduced[train.indicesR,]
test.indicesR <- (round(0.7 * nR) + 1):nR
testR <- boston.reduced[test.indicesR,]
NB = naiveBayes(review_scores_rating ~ ., data = trainR)
predictions.nb = predict(NB, newdata = testR)
mse.nb = mean((testR$review_scores_rating != predictions.nb)^2)
mse.nb
predictions.nb
?naiveBayes
NB = naivebayes(review_scores_rating ~ ., data = trainR)
NB = naiveBayes(review_scores_rating ~ ., data = trainR)
NB
predictions.nb = predict(NB, newdata = testR)
predictions.nb
head(predictions.nb)
trainR$review_scores_rating
table(testR$review_scores_rating)
table(trainR$review_scores_rating)
nR <- nrow(boston.reduced)
boston.review <- boston.reduced[sample(nR), ]
train.indicesR <- 1:round(0.7 * nR)
trainR <- boston.reduced[train.indicesR,]
test.indicesR <- (round(0.7 * nR) + 1):nR
testR <- boston.reduced[test.indicesR,]
table(testR$review_scores_rating)
nR <- nrow(boston.reduced)
boston.review <- boston.reduced[sample(nR), ]
train.indicesR <- 1:round(0.7 * nR)
nR <- nrow(boston.reduced)
boston.review <- boston.reduced[sample(nR), ]
train.indicesR <- 1:round(0.7 * nR)
trainR <- boston.review[train.indicesR,]
test.indicesR <- (round(0.7 * nR) + 1):nR
testR <- boston.review[test.indicesR,]
NB = naiveBayes(review_scores_rating ~ ., data = trainR)
predictions.nb = predict(NB, newdata = testR)
mse.nb = mean((testR$review_scores_rating != predictions.nb)^2)
mse.nb
predictions.nb
boost = boosting(review_scores_rating~., data = trainR, mfinal = 100, coeflearn = "Freund")
t
misclass.boost = boost.pred$error
misclass.boost
library(randomForest)
library(gbm)
library(rpart)
library(adabag)
library(ada)
NB = naiveBayes(review_scores_rating ~ ., data = trainR)
predictions.nb = predict(NB, newdata = testR)
mse.nb = mean((testR$review_scores_rating != predictions.nb)^2)
mse.nb
predictions.nb
trainR
